---

- assert:
    that:
      - suite is defined
      - exp_name is defined
      - id is defined
      - expstate == 'load' or expstate == 'save'
      - id == 'new' or id == 'last' or id|int > 0
      - suite_id is defined or expstate == 'load' # only on first load the suite id is not set

- name:
  set_fact:
    init_state: "{{ id == 'new' }}" # experiment design needs to be expanded + commands replaced for a new suite

##########################################################################
#   Resolve suite_id                                                     #
##########################################################################

- name: Resolve the suite_id from the playbook cmd arguments
  block:

    # case 1: suite_id is given as playbook arg
    - name: Set suite id from command argument
      set_fact:
        suite_id: "{{ id | int }}"
      when: id != 'new' and id != 'last' # continue the last experiment suite run

    # case 2: initialize a new suite_id
    - name: set the new suite_id as the epoch timestamp
      set_fact:
        suite_id: "{{ ansible_date_time.epoch | int }}"
      when: id == 'new'

    # case 3: load suite_id based on last running experiment suite
    - name: Set suite_id by creating a new one or reading the last
      block:
        - name: Find all experiments state of the experiment with '`suite`_\d+' as name
          find:
            paths: "{{ local.exp_state_dir }}"
            patterns: "^{{suite}}_\\d+$"
            file_type: directory
            use_regex: yes
          register: suite_dirs_found

        - fail:
            msg="There is no suite={{suite }} to continue with last (use 'new' to create a new one)"
          when: suite_dirs_found.matched == 0

        - name: Find the highest `suite_id`
          set_fact:
            max_suite_id: "{{ suite_dirs_found
                                  | json_query('files[*].path')
                                  | sort
                                  | last
                                  | split('_')
                                  | last }}"

        - name: Set suite ID to the highest one that was found
          set_fact:
            suite_id: "{{ max_suite_id | int }}"
      when: id == 'last'

  when: suite_id is not defined


- assert:
    that:
    - suite is defined
    - suite_id is defined
    - exp_name is defined
    - expstate == 'load' or expstate == 'save'

- debug:
    msg: "suite_id={{ suite_id }}, exp_name={{ exp_name }}"


- name: Reset experiment state to []
  set_fact:
    exp_runs_ext: []
    exp_job_ids: []
    exp_job_ids_unfinished: []
    exp_job_ids_pending: []
    exp_job_ids_queued: []
    exp_job_ids_running: []
    exp_job_ids_finished: []
  when: expstate == 'load'


##########################################################################
#   Init Experiment State    (when state does not exist)                 #
##########################################################################


- name: Set experiment directory
  set_fact:
    exp_state_dir: "{{ local.exp_state_dir }}/{{ suite }}_{{ suite_id }}/{{ exp_name }}"

- name: Check if experiment state already exists
  stat:
    path: "{{ exp_state_dir }}"
  delegate_to: localhost
  register: exp_state_dir_stat

- name: If experiment state already exists -> do not need to init
  set_fact:
    init_state: "{{ not exp_state_dir_stat.stat.exists }}"

- name: Initialize a new state by expanding the experiment runs + building commands
  block:

  - assert: # init a new state should not happen otherwise
      that:
      - expstate == 'load'
      - id == 'new'

  ################################
  # Create extended list of experiment runs by applying factors
  - name: Init the experiment state by expanding the `experiment.base_experiment` with the varying params in the experiments
    set_fact:
      exp_runs_ext: "{{ exp_runs_ext
                        | union([
                            experiment.base_experiment
                            | combine( exp_item, recursive=True )
                            | combine({ '~FACTORS_LEVEL': { 'args': exp_item } })
                        ])}}"
    loop: "{{ experiment.factor_levels }}"
    loop_control:
      loop_var: exp_item

  - assert:
      that:
      - not '$FACTOR$' in (exp_runs_ext | string)
      fail_msg: "missing level for at least one factor in the experiment config (i.e., not all '$FACTOR$' are replaced)"

  ################################
  # Replace $CMD$ in exp_runs_ext

  - name: Clear variables used for $CMD$ replacement
    set_fact:
      exp_runs_ext_wo_cmd: []
      cmds: []
      exp_runs_ext_tmp: []

  - name: create var that contains all run config without the $CMD$ 
    set_fact:
      exp_runs_ext_wo_cmd: "{{ exp_runs_ext_wo_cmd  + [my_run | combine({'$CMD$': '-', '~FACTORS_LEVEL': '-'})] | list}}"
    loop: "{{ exp_runs_ext }}"
    loop_control:
      loop_var: my_run

  - name: Create a tmp directory if it does not exist (used for cmd extension)
    ansible.builtin.file:
      path: "{{ exp_state_dir }}/tmp"
      state: directory
      mode: '0755'

  - name: Create tmp command files (each file just contains the command)
    copy:
      dest: "{{ exp_state_dir }}/tmp/cmd{{ idx }}.yml.j2"
      content: "{{ my_run['$CMD$'] }}"
    loop: "{{ exp_runs_ext }}"
    loop_control:
      index_var: idx
      loop_var: my_run

  - name: Apply templating on commands (for this we require that the template is stored in a file) -> create a list of commands
    set_fact:
      cmds: "{{ cmds + [lookup('template', '{{ exp_state_dir }}/tmp/cmd{{ idx }}.yml.j2', convert_data=False, variable_start_string='[%', variable_end_string='%]') | from_json ] }}"
    loop: "{{ exp_runs_ext_wo_cmd }}"
    loop_control:
      index_var: idx
      loop_var: run # this variable is used within the $CMD$s to refer to variables

  - name: set experiments with replaced command
    set_fact:
      exp_runs_ext_tmp: "{{ exp_runs_ext_tmp + [my_run | combine({'$CMD$': cmds[idx] })] | list}}"
    loop: "{{ exp_runs_ext }}"
    loop_control:
      index_var: idx
      loop_var: my_run

  - name: update experiments ext variable with replaced cmds
    set_fact:
      exp_runs_ext: "{{ exp_runs_ext_tmp }}"
      exp_runs_ext_tmp: []

  - name: Delete tmp content & directory used for replacement
    file:
      state: absent
      path: "{{ exp_state_dir }}/tmp/"
    

  ################################
  # Create the directory for the experiment state

  - name: Create exp directory if it does not exist
    delegate_to: localhost
    file:
      path: "{{ exp_state_dir }}"
      state: directory
      mode:  0755

  when: init_state

##########################################################################
#   Store Experiment State                                               #
##########################################################################

- name: Use previous values for undefined new state values in a state update
  block:
    - name: Load previous state
      include_vars:
        file: "{{ exp_state_dir }}/state.yml"
        name: prev_state

    - name: Set variables to previous value if undefined
      set_fact:
        n_repetitions_templ: "{{ n_repetitions_templ | default(prev_state.n_repetitions) }}"
        host_types_templ: "{{ host_types_templ | default(prev_state.host_types) }}"
        common_roles_templ: "{{ common_roles_templ | default(prev_state.common_roles) }}"
  when: experiment is not defined

- name: Set variables to prepare for saving the state
  set_fact:
    n_repetitions_templ: "{{ experiment.n_repetitions }}"
    host_types_templ: "{{ experiment.host_types }}"
    common_roles_templ: "{{ experiment.common_roles }}"
  when: experiment is defined

- name: Save the Experiment State (using state template file)
  delegate_to: localhost
  template:
    src: state.yml.j2
    dest: "{{ exp_state_dir }}/state.yml"
    mode:  0755
  when: expstate == 'save' or init_state # also store when a new experiment was initialized


##########################################################################
#   Load Experiment State                                                #
##########################################################################

- name: Load Experiment State
  # Be careful: any variables you set with set_fact will not be overwritten with
  # include_vars due to the variable precedence of different sources in Ansible.
  include_vars:
    file: "{{ exp_state_dir }}/state.yml"
    name: state

- name: Logical check that semantics of job id lists are ok
  assert:
    that:
    # check that exp_job_ids is equal to unfinished + finished
    - state.exp_job_ids | difference(test_exp_job_ids) | length == 0
    - test_exp_job_ids | difference(state.exp_job_ids) | length == 0

    # check that exp_jobs_unfinished is correct
    - state.exp_job_ids_unfinished | difference(test_exp_job_ids_unfinished) | length == 0
    - test_exp_job_ids_unfinished | difference(state.exp_job_ids_unfinished) | length == 0

    # check that no job_id is in pending, queued, running at the same time
    - test_exp_job_ids_unfinished | unique | length == test_exp_job_ids_unfinished | length 

  vars:
    test_exp_job_ids: "{{ state.exp_job_ids_unfinished|list + state.exp_job_ids_finished|list }}"
    test_exp_job_ids_unfinished: "{{ state.exp_job_ids_pending | list + state.exp_job_ids_queued | list + state.exp_job_ids_running | list }}" 


- name: Set experiment variables (facts) based on loaded state
  set_fact:
    exp_facts: "{{ exp_facts | default({}) | combine({ exp_name: { fact_item.key : fact_item.value } }, recursive=True) }}"
  loop:
    - { 'key': 'suite_id', 'value': "{{ suite_id }}" }
    - { 'key': 'exp_runs_ext', 'value': "{{ state.exp_runs_ext }}" }
    - { 'key': 'exp_job_ids', 'value': "{{ state.exp_job_ids }}" }
    - { 'key': 'exp_job_ids_unfinished', 'value': "{{ state.exp_job_ids_unfinished }}" }
    - { 'key': 'exp_job_ids_pending', 'value': "{{ state.exp_job_ids_pending }}" }
    - { 'key': 'exp_job_ids_queued', 'value': "{{ state.exp_job_ids_queued }}" }
    - { 'key': 'exp_job_ids_running', 'value': "{{ state.exp_job_ids_running }}" }
    - { 'key': 'exp_job_ids_finished', 'value': "{{ state.exp_job_ids_finished }}" }
    - { 'key': 'n_repetitions', 'value': "{{ state.n_repetitions }}" }
    - { 'key': 'common_roles', 'value': "{{ state.common_roles }}" }
  loop_control:
    loop_var: fact_item

- name: Set host types based on loaded state
  set_fact:
    host_types: "{{ host_types
                    | default({})
                    | combine({
                        host_type_item.key: {
                          exp_name: host_type_item.value
                        }
                      }, recursive=True)
                }}"
  loop: "{{ state.host_types | dict2items }}"
  loop_control:
    loop_var: host_type_item

- name: Set host type names (without the special type 'all')
  set_fact:
    host_type_names: "{{ state.host_types.keys() | list }}"

- name: Update experiment facts on all involved hosts
  set_fact:
    exp_fact: "{{ hostvars[inventory_hostname].exp_facts[exp_name] }}"
    exp_facts: "{{ hostvars['localhost'].exp_facts
                   | combine({ exp_name: hostvars[inventory_hostname].exp_facts[exp_name] }) }}"
  delegate_to: "{{ host }}"
  delegate_facts: true
  loop: "{{ exp_hosts }}"
  loop_control:
    loop_var: host
  when: exp_hosts is defined



