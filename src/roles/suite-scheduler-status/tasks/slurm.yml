# TODO [nku] SLURM


---

# Since bjobs runs multiple jobs in parallel, we ignore `job_id_to_wait_for`.
# This script waits for any of the active jobs to complete and then sets job_id_to_wait_for as one of the completed jobs.

- assert:
    that:
      - exp_name is defined

#- name: Debug what we have
#  debug:
#    msg: "{{ exp_job_ids_queued + exp_job_ids_running }}"
#
#- name: Debug wait for
#  debug:
#    msg: "{{ job_id_to_wait_for }}"

#- name: Debug
#  slurm_info:
#    job_ids: "{{ exp_job_ids_queued + exp_job_ids_running }}"
#    job_id_names: "{{ (exp_job_ids_queued + exp_job_ids_running) | map('safe_job_info_string') | list }}"
#
#  register: slurm_result
#
#- name: debug
#  debug:
#    msg: "result={{ slurm_result['complete'] }}"

- name: Store job_id that system wants us to wait for
  set_fact:
    system_job_id: "{{ job_id_to_wait_for }}"

- name: Get slurm
  slurm_info:
    job_ids: "{{ exp_job_ids_queued + exp_job_ids_running }}"
    job_id_names: "{{ (exp_job_ids_queued + exp_job_ids_running) | map('safe_job_info_string') | list }}"
  register: slurm_result
  until: slurm_result.complete | length > 0
  retries: "{{ job_n_tries }}"
  delay: "{{ job_check_wait_time }}"

- name: debug slurm
  debug:
    msg: "{{ slurm_result }}"

# TODO [nku] should maybe raise a warning if slurm_result.error is non empty

# Quick hack to be compatible with what experiment-job expects:
#   Set job_id_to_wait_for to the jsonified version of job_info
- set_fact:
    job_id_to_wait_for: "{{ slurm_result.complete | first }}"

- name: debug wait for
  debug:
    msg: "{{ job_id_to_wait_for }}"

- name: Override the job id to wait until finished + update state
  set_fact:
    exp_job_ids_queued: "{{ (exp_job_ids_queued + [system_job_id]) | difference([job_id_to_wait_for]) }}"
    exp_job_ids_running: "{{ [job_id_to_wait_for] }}"